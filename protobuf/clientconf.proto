syntax = "proto2";

package tapdance;

import "signalling.proto";

option go_package = "tdproto";

// Represents an individual config
message DeploymentConfig {
    optional DecoyList decoy_list = 1;
    optional uint32 generation = 2;
    optional PubKey default_pubkey = 3;
    optional PhantomSubnetsList phantom_subnets_list = 4;
    optional PubKey conjure_pubkey = 5;
    optional uint32 version_number = 6;
    repeated TransportType suported_transports = 7;
    repeated Registrar registrars = 8;
}

// Houses multiple deployment configs
message ClientConfig2 {
    optional uint32 version_number = 1;
    repeated DeploymentConfig deployment_configs = 2;
}

message Registrar {
    optional RegistrarType registrar_type = 1;
    optional bool bidirectional = 2;    // Expect response from registrar or not
    
    optional DNSRegConf dns_reg_conf_params = 10;

    optional APIRegConf api_reg_conf_params = 20;

    optional DecoyRegConf decoy_reg_conf_params = 30;
}

enum RegistrarType {
    REGISTRAR_TYPE_UNKNOWN = 0;
    REGISTRAR_TYPE_API = 1;
    REGISTRAR_TYPE_DECOY = 2;
    REGISTRAR_TYPE_DNS = 3;
}

enum RegistrarDNSProtocol {
    REGISTRAR_DNS_PROTOCOL_UNKNOWN = 0;
    REGISTRAR_DNS_PROTOCOL_UDP = 1;
    REGISTRAR_DNS_PROTOCOL_DOH = 2;
    REGISTRAR_DNS_PROTOCOL_DOT = 3;
}

message DNSRegConf {
    required RegistrarDNSProtocol dns_reg_method = 1;
    optional string udp_addr = 2;
    optional string dot_addr = 3;
    optional string doh_url = 4;
    required string domain = 5;
    required bytes pubkey = 6;
    optional string utls_distribution = 7;
    optional string stun_server = 8;
}

message APIRegConf {
    optional string api_url = 1;
}

message DecoyRegConf {}
